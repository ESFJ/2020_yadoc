-----------------------------------------------200605-----------------------------------------

웹상에 있는 모든걸 만드는게 웹프로그래밍 언어
  client side
    클라이언트쪽에서 (웹브라우저 안에서) 실행되는 언어 HTML, CSS, JS, Jquery
    웹브라우저만 있으면 실행됨.
  서버사이드 : 웹서버 안에서 실행되는 언어. 웹서버가 있어야 실행되는 언어


우리는 jsp하고 ...?
우리는 서버사이드쪽을 주로 배울것임

http:// 프로토콜을 사용해서 요청하고 응답이 옴.
프로토콜 : 어떤식으로 대화를 할건지 규칙을 정해놓은것

웹서비스를 제공하는 업체마다 웹서버가 있는것 -> 브라우저(클라이언트)에서 해당 웹서버로 요청을 하면 서버에서 응답하면 응답 내용이 보이는것
  요청에대한 응답을 만들어주는것이 자바쪽에서 서블릿과 jsp인것

웹 프로그래밍의 구조는 클라이언트 - 서버의 구조
클라이언트 -요청-> <응답-서버(WAS)(web app sever)(naver, google) 
웹서버는 기본적으로 정적인 페이지 서비스만을 제공한다.
  -> 이미 만들어져있는 페이지 
  -> 클라이언트에서 요청하면 이미 문서로 만들어져있는 html을 찾아서 보내주는것임(복사로 응답해줌)
  -> 동적인 요청이 들어오면? 이미 있는게 아니고 그 요청에 맞게 응답을 동적으로 생성해 보내줘야하는 요청이 있음..
    -> 원래는 못함!
    -> 동적으로 웹서버가 할수없는 응답을 할수있는 서버뒷단의 뭔가가 있어야함(SW) 

웹 애플리캐이션
  뒷단에서 동적인 요청이 들어왔을때 처리해줄수있는 것
  web controller(sevlet, jsp) 
  이 환경을 뒷받침해줄수있는 웹 컨테이너 필요
  실제로는 was와 web container 두개 필요한것임
  
Sevlet
  웹 애플리캐이션을 쓸때 자주 쓰는 언어


TOMCAT
  http://tomcat.apache.org/ -> binary dist~ -> window Service installer 다운 >  admin/admin(사용자이름/비번) -> 아파치톰캣디렉토리 -> 권한얻기 -> monitor tomcat > 하단에서 스타트서비스 -> 초록색이면 열린것 -> localhost:포트번호(local:8088) -> 기본 페이지로 들어가지면 서비스 되고있는거임

  webapps : 만드는 웹 애플리케이션들이 저장되어있는 폴더.. 
  
웹애플리케이션 만들기전에 알아줘야하는것
    웹애플리케이션 경로/구조 : 어떤 디렉토리로 들어가야 웹애플리케이션으로 인식되는지
    루트에 WebAppDir가 와야함 -> 그뒤 WEB-INF -> 그아래 classes : 그아래 컴파일된 클래스 파일들이 저장, lib : 애플리케이션에서 사용되는 라이브러리 파일들 저장
  웹서버하고 웹 컨테이너가 있는 상태!

웹 애플리케이션의 구조
  (ROOT)
  WebAppDir          
    -- WEB-INF	대소문자 구분함
      -- classes	컴파일된 클래스파일들이 저장
      -- lib	애플리케이션에서 사용되는 라이브러리
      -- web.xml	배포서술자 : 애플리케이션에 대한 설정
      -- src	(옵션) : 소스파일이 저장 (소스파일까지 묶어서 배포할땐 여기에 자바파일을 둬야함)
  *.html, *.js, *jsp, 이미지, 동영상.... 

  src를 인식하게 하는 방법
    1. javaEE 설치
    2. 기본 jdk 설치하되, 서블릿api 설치
      톰캣에 서블릿api가 있으니 사용하면 됨
      tomcat 9.0\lib\servlet-api 사용!
      cmd > 해당 소스 있는곳에서 cmd > javac -d ../classes -cp .; C:\jspStudy\Tomcat 9.0\lib;		-d 여기다 컴파일 파일을 넣어라 -cp 클래스패스로 여기도 봐라
  
 클래스파일을 또 어디 배포해줘야함
  web.xml에서 servlet-mapping관련 패턴 정의
    / 이 루트는 time의 루트
    url-pattern	해당 url이 들어옴
    servlet-name	url이 들어오면 해당 서블릿 이름 확인
    servlet	servlet-name의 내용에 대한 정의 servlet-name이 들어오면 servlet-class를 실행시킬것

이클립스를 사용하려고 해도 tomcat을 이클립스에 추가해서 넣어놓는 작업 필요
window -> proper- -> 서버 -> runtime eniv -> add -> 맞는 버전의 tomcat -> 디렉토리 찾아서 넣어줌 + jdk까지 넣어줌 -> 끝
  아래 servers탭 -> 링크 -> 설정한 tomcat 눌러서 추가
  database -> connection -> new -> oracle 선택 -> new driver 데피니션 -> 오라클 -> jdbc 설정 -> 프로퍼티 설정 -> 확인

뉴 -> 다이나믹 웹 프로젝트(원래 프로젝트 만들던거 대신 이거) -> next->next하고 web Module에서 generate web.xml 어쩌구 체크

서블릿만들기) src->new->servlet->클래스이름 지정->url 매핑 이름 바꾸고싶으면 수정(edit) -> 서블릿 생성할 method 필요한것만 체크(지금 실습에서는 doGet만 구현이니 나머지 해제)

실행) runas -> run on Server (이때 컴퓨터에서 따로 띄워놓은 톰캣은 끄고 나가야함)

화면에 나오는거 -> webContent -> jsp파일
이클립스 workspace 바꾸는 법 - > file -> switch workspace

서블릿에서 클라이언트에서 전송된 파라미터값을 받는 방법
HttpServletRequest에서 제공하는 api
String getParameter(String paramName)

요청방식
  1. GET
    1) 링크를 걸어서 요청이 전송되는 경우(링크클릭)
      단순히 주소를 쳐서 파라미터넘김x 그냥 이걸 보여줘라
      파라미터 넘길땐 진짜 단순한것만 넘김(페이지 번호정도)
      <a href = "요청하는?파라미터이름=들어오는값">[파라미터값]</a>
      ex) <a href = "LinkGet?pageNo=1">[1]</a>
    2) 주소 표시줄에 주소를 쳐서 요청
    3) form 태그를 사용해서 method 속성을 GET으로 지정하거나,
       method 속성값을 생략하는 방법(기본방식이 get으로 됨)
  여러개의 파라미터를 한번에 넘길때
    getParameterValues를 이용하면 배열로 넘어옴!
  
  2. POST
    많은 양의 파라미터값을 넘기면서 그걸로 작업을 하는 경우 사용
    1)form 태그의 metohd 속성값을 POST로 지정하는 경우
   
한글처리방법
  1) GET 방식으로 요청이 전송되어올 경우
    요청URL에 폼 파라미터가 들어감
    url로 넘어가는 데이터의 인코딩 방식을 조절하면 됨 (URL의 문자처리 방식을 조절)
    클라이언트 페이지의 인코딩 방식과 서버의 인코딩 방식을 맞추면 된다!
    전송되는 파라미터 방식 조절 법
    -> META CHARSET을 바꿈
    ->클라이언트에서 넘어갈때 인코딩방식 + 서버에 들어올때의 인코딩 방식 둘이 맞아야함
    -> 현재 클라이언트는 EUC-KR인데 서버는 UTF-8이라서 오류가 남

  2) POST 방식으로 요청이 전송되어올 경우
    요청 바디 영역에 인코딩되어 한번에 넘어감
    request body 부분의 인코딩 방식을 변경해야함!
    servlet의 doPost에서 request.setCahracterEncoding("UTF-8") 함수를 이용해 UTF-8로 바꿔줌


Model2 개발방식

Model1
  요청이 들어오면 servetl/jsp(주로jsp)(여러개일수있음, 패싱필요)에서 요청을 받음 -> 비즈니스 조직 실행 -> DB처리 -> 뷰생성 -> 응답
  클라이언트 요청이 들어오면 특정 페이지에서 요청을 처리한다음 응답
  규모가 크지 않을때는 괜찮음(디자인부터 로직까지 전부 할수있으니까)

  요구사항이 복잡할때 model1(비즈니스+뷰생성)의 사용할때 문제점
    - 분리작업x -> 뷰생성(퍼블리셔, 디자이너)와 비즈니스 조직생성(프로그래머)가 동시에 작업이 안됨 -> 생산성 저하
    - 유지보수 어려움 -> 이미 만들어진 애플리케이션을 수정할때 비즈니스 로직과 뷰가 섞여있어서 다른 부분을 수정을 하려고 해도 나머지 부분을 건드리게됨.
  
  최근 거의 사용하지 않게됨.

Model2
  비즈니스 로직과 뷰로직 분리
  서블릿에서 요청을 받고 서블릿이 컨트롤 역할을 함
  컨트롤러
    1. 비즈니스 로직을 "호출"
    2. 포워딩 (view로)

  비즈니스로직 (model)
    POJO (play of java o...?)
    DB가 연결됨

  뷰생성(View)
    *.jsp 에서 화면 생성
    화면을 구성하는건 jsp가 더 효율적임
  
  MVC 패턴 (model view control pattern)

VO (value object class) 프로그램상에서 멤버 데이터들을 다룰수있는 클래스
자주 사용하는 유틸은 따로 클래스로 빼놓는게 좋음

DB작업시 해야하는 일
  1. 해당 DBMS에서 제공하는 드라이버 클래스를 애플리케이션에서 인식할 수 있는 경로에 복붙해놓는다!
    프로젝트에서 -> 프로퍼티스 ->자바 빌드패스 -> 라이브러리 -> 모듈패스에서 add external jars -> 해당 jdbc선택 -> apply&close
    다른 시스템에서 로그인 프로젝트 실행할때는 : 다른 시스템에서 지금 참조중인 경로(jdbc있는 그 위치)가 없을수있음 -> 뉴 폴더(lib) -> jdbc 파일을 복사해서 집어넣기 -> 나머지는 동일한데 add jars해서 lib에 복사한 그 jdbc 가져오기 -> 나중에 묶어서 export해버리면 됨

  2. 드라이버 클래스를 메모리에 읽어들인다.
    해당 DB 드라이버 클래스를 메모리에 띄워야함
    
  3. Connection 객체 생성
    Connection : 데이터베이스에 연결을 하는 객체

















