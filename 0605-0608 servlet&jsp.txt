-----------------------------------------------200605-----------------------------------------

웹상에 있는 모든걸 만드는게 웹프로그래밍 언어
  client side
    클라이언트쪽에서 (웹브라우저 안에서) 실행되는 언어 HTML, CSS, JS, Jquery
    웹브라우저만 있으면 실행됨.
  서버사이드 : 웹서버 안에서 실행되는 언어. 웹서버가 있어야 실행되는 언어


우리는 jsp하고 ...?
우리는 서버사이드쪽을 주로 배울것임

http:// 프로토콜을 사용해서 요청하고 응답이 옴.
프로토콜 : 어떤식으로 대화를 할건지 규칙을 정해놓은것

웹서비스를 제공하는 업체마다 웹서버가 있는것 -> 브라우저(클라이언트)에서 해당 웹서버로 요청을 하면 서버에서 응답하면 응답 내용이 보이는것
  요청에대한 응답을 만들어주는것이 자바쪽에서 서블릿과 jsp인것

웹 프로그래밍의 구조는 클라이언트 - 서버의 구조
클라이언트 -요청-> <응답-서버(WAS)(web app sever)(naver, google) 
웹서버는 기본적으로 정적인 페이지 서비스만을 제공한다.
  -> 이미 만들어져있는 페이지 
  -> 클라이언트에서 요청하면 이미 문서로 만들어져있는 html을 찾아서 보내주는것임(복사로 응답해줌)
  -> 동적인 요청이 들어오면? 이미 있는게 아니고 그 요청에 맞게 응답을 동적으로 생성해 보내줘야하는 요청이 있음..
    -> 원래는 못함!
    -> 동적으로 웹서버가 할수없는 응답을 할수있는 서버뒷단의 뭔가가 있어야함(SW) 

웹 애플리캐이션
  뒷단에서 동적인 요청이 들어왔을때 처리해줄수있는 것
  web controller(sevlet, jsp) 
  이 환경을 뒷받침해줄수있는 웹 컨테이너 필요
  실제로는 was와 web container 두개 필요한것임
  
Sevlet
  웹 애플리캐이션을 쓸때 자주 쓰는 언어


TOMCAT
  http://tomcat.apache.org/ -> binary dist~ -> window Service installer 다운 >  admin/admin(사용자이름/비번) -> 아파치톰캣디렉토리 -> 권한얻기 -> monitor tomcat > 하단에서 스타트서비스 -> 초록색이면 열린것 -> localhost:포트번호(local:8088) -> 기본 페이지로 들어가지면 서비스 되고있는거임

  webapps : 만드는 웹 애플리케이션들이 저장되어있는 폴더.. 
  
웹애플리케이션 만들기전에 알아줘야하는것
    웹애플리케이션 경로/구조 : 어떤 디렉토리로 들어가야 웹애플리케이션으로 인식되는지
    루트에 WebAppDir가 와야함 -> 그뒤 WEB-INF -> 그아래 classes : 그아래 컴파일된 클래스 파일들이 저장, lib : 애플리케이션에서 사용되는 라이브러리 파일들 저장
  웹서버하고 웹 컨테이너가 있는 상태!

웹 애플리케이션의 구조
  (ROOT)
  WebAppDir          
    -- WEB-INF	대소문자 구분함
      -- classes	컴파일된 클래스파일들이 저장
      -- lib	애플리케이션에서 사용되는 라이브러리
      -- web.xml	배포서술자 : 애플리케이션에 대한 설정
      -- src	(옵션) : 소스파일이 저장 (소스파일까지 묶어서 배포할땐 여기에 자바파일을 둬야함)
  *.html, *.js, *jsp, 이미지, 동영상.... 

  src를 인식하게 하는 방법
    1. javaEE 설치
    2. 기본 jdk 설치하되, 서블릿api 설치
      톰캣에 서블릿api가 있으니 사용하면 됨
      tomcat 9.0\lib\servlet-api 사용!
      cmd > 해당 소스 있는곳에서 cmd > javac -d ../classes -cp .; C:\jspStudy\Tomcat 9.0\lib;		-d 여기다 컴파일 파일을 넣어라 -cp 클래스패스로 여기도 봐라
  
 클래스파일을 또 어디 배포해줘야함
  web.xml에서 servlet-mapping관련 패턴 정의
    / 이 루트는 time의 루트
    url-pattern	해당 url이 들어옴
    servlet-name	url이 들어오면 해당 서블릿 이름 확인
    servlet	servlet-name의 내용에 대한 정의 servlet-name이 들어오면 servlet-class를 실행시킬것

이클립스를 사용하려고 해도 tomcat을 이클립스에 추가해서 넣어놓는 작업 필요
window -> proper- -> 서버 -> runtime eniv -> add -> 맞는 버전의 tomcat -> 디렉토리 찾아서 넣어줌 + jdk까지 넣어줌 -> 끝
  아래 servers탭 -> 링크 -> 설정한 tomcat 눌러서 추가
  database -> connection -> new -> oracle 선택 -> new driver 데피니션 -> 오라클 -> jdbc 설정 -> 프로퍼티 설정 -> 확인

뉴 -> 다이나믹 웹 프로젝트(원래 프로젝트 만들던거 대신 이거) -> next->next하고 web Module에서 generate web.xml 어쩌구 체크

서블릿만들기) src->new->servlet->클래스이름 지정->url 매핑 이름 바꾸고싶으면 수정(edit) -> 서블릿 생성할 method 필요한것만 체크(지금 실습에서는 doGet만 구현이니 나머지 해제)

실행) runas -> run on Server (이때 컴퓨터에서 따로 띄워놓은 톰캣은 끄고 나가야함)

화면에 나오는거 -> webContent -> jsp파일
이클립스 workspace 바꾸는 법 - > file -> switch workspace

서블릿에서 클라이언트에서 전송된 파라미터값을 받는 방법
HttpServletRequest에서 제공하는 api
String getParameter(String paramName)

요청방식
  1. GET
    1) 링크를 걸어서 요청이 전송되는 경우(링크클릭)
      단순히 주소를 쳐서 파라미터넘김x 그냥 이걸 보여줘라
      파라미터 넘길땐 진짜 단순한것만 넘김(페이지 번호정도)
      <a href = "요청하는?파라미터이름=들어오는값">[파라미터값]</a>
      ex) <a href = "LinkGet?pageNo=1">[1]</a>
    2) 주소 표시줄에 주소를 쳐서 요청
    3) form 태그를 사용해서 method 속성을 GET으로 지정하거나,
       method 속성값을 생략하는 방법(기본방식이 get으로 됨)
  여러개의 파라미터를 한번에 넘길때
    getParameterValues를 이용하면 배열로 넘어옴!
  
  2. POST
    많은 양의 파라미터값을 넘기면서 그걸로 작업을 하는 경우 사용
    1)form 태그의 metohd 속성값을 POST로 지정하는 경우
   
한글처리방법
  1) GET 방식으로 요청이 전송되어올 경우
    요청URL에 폼 파라미터가 들어감
    url로 넘어가는 데이터의 인코딩 방식을 조절하면 됨 (URL의 문자처리 방식을 조절)
    클라이언트 페이지의 인코딩 방식과 서버의 인코딩 방식을 맞추면 된다!
    전송되는 파라미터 방식 조절 법
    -> META CHARSET을 바꿈
    ->클라이언트에서 넘어갈때 인코딩방식 + 서버에 들어올때의 인코딩 방식 둘이 맞아야함
    -> 현재 클라이언트는 EUC-KR인데 서버는 UTF-8이라서 오류가 남
      -> window -> preferences -> Web -> JSP files -> encoding을 UTF-8로 변경

  2) POST 방식으로 요청이 전송되어올 경우
    요청 바디 영역에 인코딩되어 한번에 넘어감
    request body 부분의 인코딩 방식을 변경해야함!
    servlet의 doPost에서 request.setCahracterEncoding("UTF-8") 함수를 이용해 UTF-8로 바꿔줌


Model2 개발방식

Model1
  요청이 들어오면 servetl/jsp(주로jsp)(여러개일수있음, 패싱필요)에서 요청을 받음 -> 비즈니스 조직 실행 -> DB처리 -> 뷰생성 -> 응답
  클라이언트 요청이 들어오면 특정 페이지에서 요청을 처리한다음 응답
  규모가 크지 않을때는 괜찮음(디자인부터 로직까지 전부 할수있으니까)

  요구사항이 복잡할때 model1(비즈니스+뷰생성)의 사용할때 문제점
    - 분리작업x -> 뷰생성(퍼블리셔, 디자이너)와 비즈니스 조직생성(프로그래머)가 동시에 작업이 안됨 -> 생산성 저하
    - 유지보수 어려움 -> 이미 만들어진 애플리케이션을 수정할때 비즈니스 로직과 뷰가 섞여있어서 다른 부분을 수정을 하려고 해도 나머지 부분을 건드리게됨.
  
  최근 거의 사용하지 않게됨.

Model2
  비즈니스 로직과 뷰로직 분리
  서블릿에서 요청을 받고 서블릿이 컨트롤 역할을 함
  컨트롤러
    1. 비즈니스 로직을 "호출"
    2. 포워딩 (view로)

  비즈니스로직 (model)
    POJO (play of java o...?)
    DB가 연결됨

  뷰생성(View)
    *.jsp 에서 화면 생성
    화면을 구성하는건 jsp가 더 효율적임
  
  MVC 패턴 (model view control pattern)

VO (value object class) 프로그램상에서 멤버 데이터들을 다룰수있는 클래스
자주 사용하는 유틸은 따로 클래스로 빼놓는게 좋음

DB작업시 해야하는 일
  1. 해당 DBMS에서 제공하는 드라이버 클래스를 애플리케이션에서 인식할 수 있는 경로에 복붙해놓는다!
    프로젝트에서 -> 프로퍼티스 ->자바 빌드패스 -> 라이브러리 -> 모듈패스에서 add external jars -> 해당 jdbc선택 -> apply&close
    다른 시스템에서 로그인 프로젝트 실행할때는 : 다른 시스템에서 지금 참조중인 경로(jdbc있는 그 위치)가 없을수있음 -> 뉴 폴더(lib) -> jdbc 파일을 복사해서 집어넣기 -> 나머지는 동일한데 add jars해서 lib(WebContent의 WEB-INF의 lib)에 복사한 그 jdbc 가져오기 -> 나중에 묶어서 export해버리면 됨

  2. 드라이버 클래스를 메모리에 읽어들인다.
    해당 DB 드라이버 클래스를 메모리에 띄워야함
    
  3. Connection 객체 생성
    Connection : 데이터베이스에 연결을 하는 객체
++-

------------------------------------------------0608---------------------------------------
data source explorer -> 원하는 DB, 계정 -> 원하는 table에서 우클릭, edit 하면 테이블이 나옴

공통적으로 사용되는 코드를 JDBCUtil로 정리

Java Rexources : 코드
WebContent : 웹페이지의 생김새를 정의
style정의할때 
  #sectionID이용, style탭에선 화면에 어떻게 구성되는지 정의할 수 있음
  input[type="ㅁㅁ"]: input중 type이 "ㅁㅁ"인 것의 스타일 정의

AVC패턴
  컨테이너로 요청을 보내면 컨테이너에서 해당 요청을 처리할 서블릿을 호출
  서블릿에서는 모델에 해당하는 뒷단의 클래스로 비즈니스 로직을 호출
  요청처리한 결과를 가지고 view에 해당하는 jsp로 호워딩해서 jsp에서 컨테이너로 화면 반환
  컨테이너에서 받은 결과를 가지고 클라이언트에게 응답
  서블릿이 컨트롤러, 비즈니스로직 수행하는곳이 모델, jsp가 뷰

URL Mapping값이 action값과 같아야함
서비스 로직은 svc

singleton 패턴이란?
  객체의 인스턴스를 하나만 메모리에 생성하고 공유해서 사용하는 방식
	
  로그인 DAO에 정의되어있는 메소드를 사용할때 호출하는 클래스마다 로그인다오 객체를 생성하지않고
  특정 클래스에서 처음에 다오를 사용할때만 메모리에 한번 생성을 하고
  그 뒤로는 처음에 만든 그 객체를 사용하는것임(메모리 효율)
  DAO는 자주 호출되는데 해당 기능이 필요할때마다 객체를 생성하면 호출될수록 객체가 너무 많이 생성되어 메모리가 차는것을 방지하기위함
	
  객체의 특정 속성값을 따로 저장하지않고(속성값이 의미있지 x) 로그인다오처럼 특정 기능이 정의된 클래스들이 있음

  VO의 경우는 회원마다 객체가 필요한데 (속성값에 의미가 있음) DAO는 빈번하게 호출되는 기능, 메소드에 의미가 있는 클래스가 있는데 얘네는 굳이 객체를 만들 필요가 없음
인스턴스에 참조만 할수있도록 싱글톤패턴으로 정의함. 고정화된 값


자바에서의 디비작업
1. 드라이버 클래스를 애플리케이션에서 인식할 수 있는 경로에 붙인다.
2. java.sql.*를 임포트한다.
3. Connection 객체를 생성한다. 
4. Statement 객체를 생성한다.
  Statement객체 : SQL구문을 실행하는 객체

  1) int executeUpdate(String sql)
    sql = 실행할 sql구문
    SELECT 구문을 제외한 데이터를 조작하는 구문 실행
    delete, update, insert 등을 실행
    리턴값 : 적용된 레코드 갯수(행수)
    
  2) ResultSet executeQuery(String sql)
    SELECT 구문을 실행
    리턴값 : SELECT구문에 의해 반환된 레코드셋(데이터 덩어리)(테이블형태의 데이터)

  3) ResultSet 인터페이스의 주요 메소드
    resultSet은 처음엔 데이터를 가리키지 않고 top을 가리키고있음 -> 메소드 이용해 원하는 레코드 이동
    boolean next(): 커서를 다음 레코드로 이동시킴. -> 다음 레코드가 있으면 true, 없으면 false
    Type getType(int columnNumber) : 인자로 지정된 컬럼번호의 컬럼값을 반환
      String id = rs.getString(1); -> 해당 라인의 1번째 데이터 	-> 컬럼연산시 사용(컬럼 이름이 없어졌을때 사용)
    Type getType(String columnName) : 인자로 지정된 이름의 컬럼의 값을 반환
      String id = rs.getString("id");	-> 가독성때문에 이쪽을 더 권장


화면에 보이는 것CSS
화면에서 하는 동작 JS :이미지의 모양이 바뀌거나 밑줄이 생기거나 하는 등 동적인 동작을 주는 것

사용자 정보 출력하는 작업은 JS
정보를 리턴받은 페이지는 서블릭, 정보를 보여주는 페이지는 jsp
jsp는 화면을 만들 정보를 갖고있지않음
포워딩전에 jsp에서 접근할수있는 영역에 DB에서 가죠온 로그인에 성공한 유저의 정보를 공유한 뒤 포워딩해야함  
			
서블릿에서 데이터 공유하는 방법
  1.초기화 파라미터를 이용하는 방법
    web.xml에 초기화 파라미터를 정의해서 공유 (프레임워크 사용시 사용)
  2. 속성을 사용하는 방식
    1) 속성 생성 (서블릿에서 작업)
      영역객체.setAttribute(String attrName, Object attrValue)

    2) 속성 사용(JSP에서 작업)
      Object 영역객체.getAttribute(String attrName)

    3)영역객체 종류
      page : 동일 페이지 내에서만 공유 -> 객체가 생성된 페이지 내에서만 (로컬변수같은 느낌)
      request : 하나의 요청을 처리하기 위해서 읽혀지는 모든 페이지에서 공유(응답 만들때까지 모든 영역)
      session : 하나의 사용자(브라우저)에서 공유 (브라우저 끄기 전까지 공유)
      application : 잘안씀. 애프리케이션 당 공유 (서버를 끄기 전까지 공유)
    -> 상황에 (서블릿에서 뷰페이지로 포워딩하는 두 방식)따라 객체를 다르게 함

서블릿에서 JSP로 포워딩하는 방법
  1. 디스패치 방식
    페이지 전환이 서버 상에서 이루어짐
    내부적으로만 포워딩해서 결과만 내부적으로 JSP에서 이루어짐.
    주소표시줄의 주소는 변하지 않음 -> 요청이 변경되지 않음(request가 변하지않음)
    이 서블릿으로 요청을 했을때 이 서블릿 요청에서 jsp로 바뀌냐 안바뀌냐의 이야기(포워딩만의 얘기)
    RequestDispatcher dispatcher = request.getRequestDispatcher(포워딩할 jsp 주소 들어감)
    화면은 jsp의 결과창이 나오지만 주소창에는 서블릿에서 요청했던 주소로 보임 포워딩하는 페이지의 주소로 바뀌지 않음
    서블릿에서 참조하는 객체가 jsp에서 참조하는 객체와 같다(공유된다)
    ex) 게시판 목록, 쇼핑몰 상품보기, 주로 리스팅할때 디스패치 방식 사용

  2. 리다이렉트 방식
    브라우저 주소가 변경됨.
    요청이 변경됨
    요청을 바꿀때 사용
    리스팅요청이 아니고 게시판에 새로운 글을 등록하는 요청같을때 사용
    서블릿으로 되돌아왔을때 새로 등록한 글까지의 글목록을 보여줄때 사용
    -> 글 작성을 완료하고 목록으로 돌아왔는데 f5를 누르면 다시 글작성 페이지로 들어감
    -> 새로운 요청으로 목록보기 요청이 들어와야하는것!    
    response.sendRedirect("forwardTo.jsp");
    대신 서블릿과 jsp의 객체가 달라짐!
    -> request가 아니라 session으로 공유되게 해야함

  서블릿에서 세션에 접근할땐 api를 이용해 세션객체를 만들고 세션을 얻어와 사용
  jsp에서는 세션객체 이름을 바로 가져와 사용
    jsp로 요청이 들어가면 jsp페이지가 서블릿에 해당하는 자바코드로 변환후 서블릿과 같은 라이프사이클을 거치면서 서비스됨 (JSP도 서블릿임 서블릿을 상속받아 사용)
    ->org.apache.jasper.runtime.HttpJspBase	JSP용 서블릿
    ->_jspService	JSP용 서비스 메소드
    -> 내장 객체들이 자동으로 생성됨


jsp는 전체적으로 html의 형식을 따르는데 <%%>을 통해 jsp를 사용함
%= : Expressiong Tag : out.print()와 동일한 역할

DB에러날땐
  컴퓨터관리 -> 서비스 : oracleServiceXE, OracleXETMSListener 잘 돌고있는지 확인
  아니면 걍 코드 오타임


쿠키
  클라이언트에 정보를 저장하는 단위
  특정 사이트에 클라이언트에 접속했을때 나중에 다시 접속했을때 보여줄 정보를 클라이언트시스템에 저장해놓고 불러와 쓰는것
  1. client -1번째 요청-> server
    1. 쿠키 객체 생성 (server)
    2. 쿠키에 정보 저장 (server)
    3. 응답에 쿠키객체 추가 (server) (append)
  2. client <-응답 + 쿠키객체 - server
    client쪽에 쿠키저장소에 쿠키가 저장됨(Client)
  3. client - 2번째 요청 + 쿠키객체 -> server
    4. server쪽에서 쿠키 사용 (server)

  쿠키가 저장되는 방법
    cookieName = cookieValue;
    쿠키 이름과 값이 쌍으로 들어감

  쿠키객체의 생존기간
    -1(브라우저가 꺼지면 쿠키가 즉시 소멸됨)
    setMaxAge로 생존기간 설정 (단위는 초)


세션
  클라이언트와 서버의 통신상태를 유지시키는 기능
  세션을 알려면 HTTP프로토콜의 특성을 알아야함
  http 프로토콜의 특성 : stateless 
    상태를 유지시키지 않음
      1. client - 1번째 요청 -> server
      2. client <- 1번째 요청에 대한 응답 - server
      3. client --연결 끊음 --server

  Session사용
  1번째 요청과 2번째 요청이 같은 사용자임을 기억
      1. client - 1번째 요청 -> server
        server쪽에 세션영역이 생기고 session_ID생성
      2. client <- 1번째 요청에 대한 응답 + sessionID - server
        Client쪽 쿠키에 session_ID 저장됨
      3. client - 2번째 요청 + sessionID -> server


베이직에서 완전한 모델툴로
version2의 Model2로 바꾸기

  현재
    요청당 servlet하나씩 만들어서 처리

  일반적 (FrontController 패턴)
    관련된 여러개의 요청을 한번에 처리하는 대표 서블릿 만듦(FrontController)
    요청마다 핸들링
      모듈이름+FronController
      URLMapping 이름은 완전한 URL -> 그 이름으로 URL이 들어온 경우만 처리 가능
      URL패턴을 완전한 이름x, URL유형(*.me : ) -> 앞은 상관없고 맨뒤글자가 .me로 끝나면 전부 여기로 들어온다 여러종류 요청 처리
      요청이 어떤 방식으로 들어올지 모름 -> 메소드는 doGet doPost 둘다 정의 + 각 요청마다 doGet, doPost 둘다 만들어줘야함
      어떤 방식으로 넘어오든 공통적으로 처리해줘야하는 일이 있음 -> 하나의 메소드에서 둘다 처리

    서블릿에서 해야하는 일
      1. 요청 파악
      2. 각 요청 처리(다형성 이용)
        Action인터페이스 사용
          -> 각 요청을 처리하는 Action 클래스의 규격을 정의
          -> 각각의 컨트롤러에 해당하는 부분임
      3. 뷰페이지로 포워딩        
        리다이렉트 / 디스패치

트랜잭션 처리
  데이터 조작시 필요 (DMA처리시 필요)
  데이터의 변경 작업을 완성(commit)할지 취소(rollback)할지

트랜잭션 처리하는 법
connection의 autocommit을 false
작업 성공 -> commit
작업 실패 - > rollback

자바 API에서 SQL구문 실행하는 인터페이스
  1. Statement
    정적인 SQL구문을 실행할때 사용
    SQL 구문을 실행할 때 마다 매번 컴파일해야함. (-> 반복작업시 느림)

  2. PreparedStatement
    Statement를 상속받음
    동적인 SQL구문을 실행
    PreparedStatement 객체를 생성할 때 단 한번 컴파일을 하고 두번다시 컴파일하지 않음!! (-> 효율적임)
    변수가 들어갔던 자리에 ?를 써서 setString으로 매핑시켜줌

















